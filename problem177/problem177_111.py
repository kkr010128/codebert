import pprint
N=int(input())
A=list(map(int,input().split()))
if N%2==0:#偶数なら1回まで2こ飛ばしで無茶できる
    dp=[[-float("inf") for _ in range(2)] for _ in range(N+10)]#dpはj=0の時は無茶をしていない系列j=1の時は1回無茶をした系列である
    if N==2:#2の時は個別
        print(max(A[0],A[1]))
    else:#それ以外の時は
        for i in range(N):
            if i==0:            #i=0をとる時の任意の系列は無茶を確実にしていないのでdp[i][0]のみA[0]
                dp[0][0]=A[0]
            elif i==1:          #i=1をとる時の任意の系列は一回無茶をして取っているはずである、よってdp[i][1]のみA[1]
                dp[1][1]=A[1]
            elif i==2:          #i=2をとる時の任意の系列は一回も無茶せずに先頭からとっているのでdp[i][0]=A[0]+A[2]
                dp[2][0]=A[0]+A[2]
            else:                   #そのほかは再帰的に考える
                for j in range(2):
                    if j==0:                                                    #無茶しない系列を生成する時
                        dp[i][0]=max(dp[i][0],dp[i-2][0]+A[i])                  #そこまでの無茶しなかった系列に自らを足していけば良い
                    elif j==1:                                                  #一回無茶する系列を生成する時
                        dp[i][1]=max(dp[i][1],dp[i-2][1]+A[i],dp[i-3][0]+A[i])  #すでにある無茶した時の値(いらない？)と、前までの系列で無茶していて今回は無茶できないパターン、今回で無茶をするパターンのうち最大を用いて系列生成すれば良い
        print(max(dp[N-1][1],dp[N-2][0]))                                       #1回も飛ばさない時は後ろから二番目のdp値が相当することに注意
else:#奇数なら計2回まで無茶できる(2飛ばし×2、3飛ばし×1まで許容)
    #print(A[0],A[1])
    dp=[[-float("inf") for _ in range(3)] for _ in range(N+10)]#dpはj=0の時は無茶をしない系列j=1は1回無茶をした系列、j=2は2回無茶をしている系列
    if N==3:#N=3の時は個別
        print(max(A[0],A[1],A[2]))
    else:#それ以外の時は
        for i in range(N):
            if i<4:
                if i==0:                                        #i=0をとる任意の系列は無茶を確実にしていないのでdp[i][0]のみA[0]
                    dp[0][0]=A[0]
                if i==1:                                        #i=1をとる任意の系列は確実に1回無茶をしているのでdp[i][1]のみA[1]
                    dp[1][1]=A[1]
                if i==2:                                        #i=2をとる時は2回分の無茶をしてA[2]を得る時(dp[i][2]=A[2])および1かいも無茶せずに撮っている時(dp[i][0]=A[2]+A[0])
                    dp[2][2]=A[2]
                    dp[2][0]=A[0]+A[2]
                if i==3:                                        #i=3をとる時は1回目で無茶をしてそのあと無茶していないパターン(dp[1][1]+A[3])といきなり1回無茶をしたパターン(dp[0][0]+A[3])があるのでその最大を
                    dp[3][1]=max(dp[1][1]+A[3],dp[0][0]+A[3])
            else:                                                                               #そのほかは再帰的に
                for j in range(3):
                    if j==0:                                                                    #無茶してない系列を生成する時、
                        dp[i][0]=max(dp[i][0],dp[i-2][0]+A[i])                                  #そこまでの無茶しなかった系列に自らを足していけば良い
                    elif j==1:                                                                  #1回だけ無茶した系列を生成する時
                        dp[i][1]=max(dp[i][1],dp[i-2][1]+A[i],dp[i-3][0]+A[i])                  #すでにある1回無茶した時の値(いらない？)と、前までの系列で1回無茶していて今回は無茶しないパターン、今回で初めて無茶をするパターンのうち最大を用いて系列生成すれば良い
                    else:                                                                       #2回無茶した系列を生成する時
                        dp[i][2]=max(dp[i][2],dp[i-2][2]+A[i],dp[i-3][1]+A[i],dp[i-4][0]+A[i])  #すでにある2回無茶した時の値(いらない？)と、もう二回無茶していて無茶できないパターン、前までの系列で1回無茶していて今回も1回無茶するしないパターン、今回でいきなり2回無茶をするパターンのうち最大を用いて系列生成すれば良い
        print(max(dp[N-1][2],dp[N-2][1],dp[N-3][0]))                                            #1回も飛ばさない時は後ろから3番目が、1回だけ飛ばした時は後ろから2番目のdp値が相当することに注意