# 0がX個、1がY個ある(ただしX+Y=N)とき、Xorの組み合わせ自体は N*(N-1)//2 通りある。
# しかし、それらの和をとることを考えてみた時
# (0,0)と(1,1)を選んだ場合はそのXORは0になることに注意すると、(0,1)の組み合わせの個数だけ数えれば良い。
# これは、たとえば　〇〇〇●●●●(X=3,Y=4)から〇と●を選ぶ組み合わせは何個あるか、という問いと同じことなので
# Nの値には依存することはなく、単純にX*Y通りとなる。
# よって
# ΣΣ A_i Xor A_j = X*Y
# この処理によって、O(N^2)が、O(N)(=Aの各数字を一通り調べる)に減らせる。
# これを各ケタについて計算し、合計すれば良い。
# ケタ数が60まで定まっているので 計算量は O(Nlog(max(A)))≦ O(N*60)
# あるケタのbitを取り出すには ビットシフト「>>」でずらして下1ケタだけを見ると便利。


N=int(input())
A=list(map(int,input().split()))
p=10**9+7

ans=0
for k in range(60):
    cnt_z=0
    cnt_o=0
    #print(A)
    for i in range(N):
        s=A[i]%2
        if s==0:
            cnt_z +=1
        else:
            cnt_o +=1
        A[i] >>= 1
    ans += ((2**k)*cnt_z*cnt_o)%p
       
print(ans%p)