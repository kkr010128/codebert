#!/usr/bin/env python3
import sys

MOD = 1000000007  # type: int

class Factorial:
    def __init__(self,MOD):
        self.MOD = MOD
        self.factorials = [1,1] # 階乗を求めるためのキャッシュ
        self.invModulos = [0,1] # n^-1のキャッシュ
        self.invFactorial_ = [1,1] # (n^-1)!のキャッシュ

    def calc(self,n):
        if n <= -1:
            print("Invalid argument to calculate n!")
            print("n must be non-negative value. But the argument was " + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0]*(n+1-len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI,n+1):
            prev = nextArr[i-initialI] = prev * i%m
        self.factorials += nextArr
        return self.factorials[n]
    
    def inv(self,n):
        if n <= -1:
            print("Invalid argument to calculate n^(-1)")
            print("n must be non-negative value. But the argument was " + str(n))
            exit() 
        p = self.MOD
        pi = n%p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0]*(n+1-len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI,min(p,n+1)):
            next = -self.invModulos[p%i]*(p//i)%p
            self.invModulos.append(next)
        return self.invModulos[pi]
    
    def invFactorial(self,n):
        if n <= -1:
            print("Invalid argument to calculate (n^(-1))!")
            print("n must be non-negative value. But the argument was " + str(n))
            exit() 
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n) # To make sure already calculated n^-1
        nextArr = [0]*(n+1-len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI,n+1):
            prev = nextArr[i-initialI] = (prev * self.invModulos[i%p])%p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self,MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
    
    def choose_k_from_n(self,n,k):
        if k < 0 or n < k:
            return 0
        k = min(k,n-k)
        f = self.factorial
        return f.calc(n)*f.invFactorial(max(n-k,k))*f.invFactorial(min(k,n-k))%self.MOD


def solve(n: int, k: int):
    c = Combination(MOD)
    sum = 0
    for i in range(min(n,k+1)-1,-1,-1):
        c1 = c.choose_k_from_n(n,i)
        c2 = c.choose_k_from_n(n-1,i)
        sum = (sum + c1*c2)%MOD
    print(sum)
    return


# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    n = int(next(tokens))  # type: int
    k = int(next(tokens))  # type: int
    solve(n, k)

if __name__ == '__main__':
    main()
