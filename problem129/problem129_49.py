# 30分ぐらい？で溶けた！計算量は直感だよりだったが。
# → エラトステネスの篩 に相当する実装らしい。

# リスト内の倍数・約数関係を判定し、カウントする。
# 二重ループで判定するとTLEになるため、小さい値の可能な倍数を計算して保存するようにした。
# メモを set() ではなく 配列 で実装するテスト

n=int(input())
a=list(map(int,input().split()))
a.sort()

# 小さい側から処理する。a[i]について、10**6 以下のすべての倍数をset()として持つ。
# ただし、set内に存在しない==初出の約数のみ倍数計算をしてカウントする。
# 例えば、2,6,... となった場合、(6の倍数セットは2の倍数セットの下位集合となるため計算不要)

s=[False]*(10**6+1)
cnt=0
for i,aa in enumerate(a):
  if s[aa]:
    continue

  # 同値が複数ある場合、カウントしない。
  if i+1 == len(a) or aa != a[i+1]:
    cnt+=1
  for i in range(1,10**6+1):
    ma=aa*i
    if ma > 10**6:
      break
    s[ma]=True

print(cnt)
    
